---
title: JavaScript 学习笔记
created: 2020-03-12
tag: 笔记本
summary: 本文系统阐述 JavaScript 知识。涵盖其核心（ECMAScript）、DOM 与 BOM 组成，详述语法规则、丰富运算符、多种语句及函数特性，深入剖析 BOM 和 DOM 各对象功能。亦介绍 AJAX 原理及操作、数据存储机制对比，为掌握 JavaScript 编程与应用提供全方位指引。
---

## JavaScript 的组成

1. 核心 (ECMAScript):由 ECMA 国际(前身为欧洲计算机制造商协会，European Computer Manufacturers Association)通过 ECMA-262 标准化的脚本程序设计语言。

2. 文档对象模型(Document Object Model，简称DOM):是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。描述了访问网页元素的方法和接口。

3. 浏览器对象模型(Browser Object Model，简称BOM):描述了与浏览器进行交互的方法和接口。

## 基本语法

1. 注意行尾加分号;
2. 换行书写;
3. 单行注释:// 或者多行注释/**/
4. 补充:页面输出语句;

```js
alert('Hello Word') // 系统弹窗
console.log() // 输出在控制台
document.write() // 打印在页面
```

## JavaScript的常用运算符:

1. 算术运算符:`+` `-` `*` `/` `%` `++` `--`

**🐔 i++ 与 ++i 的区别:**

- 如果单独在一行，都自增1；
- 当与其他运算符或者输出语句一起使用时:
  - i++:先赋值使用，再运算；(++在后，先用后加)
  - ++i:先运算，再赋值使用；(++在前，先加后用)

2. 比较运算符:`>` `>=` `<` `<=` `==` `!=` ,返回结果:真或假(true/false)

3. 逻辑运算符:`&&` `||` `!` (`与`、`或`、`非`)
  - &&:两边为真，才为真。其中一个为假，即为假。
  - ||:其中一个为真，即为真。
  - ！:真假互换。

4. 条件运算符:(表达式1 ? 表达式2 : 表达式3)
  - 判断“表达式1”的结果是否为真，
  - 如果为真则执行“表达式2”，否则执行“表达式3”。

## 条件分支语句:if、switch

- **if语句:**

```js
语法:
if (条件表达式) {
  语句块
}
```

- **if…else语句:**

```js
语法:
if (条件表达式) {
  语句块1
}
else {
  语句块2
}
```

**多分支if语句(if…else if 语句):**

```js
语法:
if(条件表达式1){
  语句块1;
}else if(条件表达式2){
  语句块2;
}
......
else{
  语句块N;
}
```

**switch语句:**

```js
switch(表达式){
  case 值1:
    语句块1;
    break;
  ......
  case 值N:
    语句块N;
    break;
  default:
    语句块;
    break;
}
```

## 循环语句:

- while
- do…while
- for
- for in
- break和continue的使用

*while循环:*

```js
while (条件表达式) {
  循环语句
}
```

> 执行流程:判断条件表达式是否为真，如果为真，就执行后面的循环语句。然后再次判断，直到条件为假时，跳出while循环。

**do…while循环:**

```js
do {
  循环语句
}
while (条件表达式)
```

> 执行流程:先执行语句，再判断条件，如果为真就继续执行循环语句。否则跳出循环。

while与do-while的区别: while先判断再执行，do-while先执行后判断(至少执行一次)。

**for循环:**

```js
for (初始表达式1; 条件表达式2; 迭代表达式3) {
  循环语句4
}
```

- for in (对象篇详解)
- break:跳出循环
- continue: 跳过该次循环，执行后面的循环

## 关键词与变量命名

- ECMAScript 关键字的完整列表:

| _ | _ | _ | _ |
| --- | --- | --- | --- |
| **break** | **else** | **new** | **var** |
| **case** | **finally** | **return** | **void** |
| **catch** | **for** | **switch** | **while** |
| **continue** | **function** | **this** | **with** |
| **default** | **if** | **throw** | **let** |
| **delete** | **in** | **try** | **do** |
| **instanceof** | **typeof** |  |  |

- 定义变量

变量variable(临时存储的容器)
变量:临时存储信息的容器，可以复用

- var name; //变量的声明，并起名叫 name
- name = “tt”; //为变量赋值,`=` 等号:是把右侧的值，`赋值`给左侧的变量名；
- 变量名大小写敏感

```js
var Name=“小花”;
var name=“小毛”;
```

**命名规范:**

1. 必须以字母、数字、下划线或$组成。

2. 开头不能是数字。

3. 不能是 JavaScript 的关键字。

**注意:由于 JavaScript 是弱类型语言，所以在定义变量时，可以省略 var，但是不建议使用。**

## JavaScript 中的两种数据类型

### 原始类型:(查看数据类型，使用: typeof )

1. boolean
2. number
3. string
4. undefined:变量只定义不赋值，就是undefined
5. null:表示一个空对象，“什么都没有”的意思，用来表示无值，就像一个占位符

### 对象类型(object)

**对象的定义为:“无序属性的集合，其属性可以包含基本值、对象、或者函数”。**

- js中内置了如下的对象:

| 对象 | 说明 |
| --- | --- |
| Object | 是所有JS对象的超类(基类)，JS中的所有对象都是继承自Object对象 |
| Array | 数组对象–定义数组属性和方法 |
| Number | 数字对象 |
| Boolean | 布尔对象–布尔值相关 |
| Error | 错误对象–处理程序错误 |
| Function | 函数对象–定义函数属性和方法 |
| Math | 数学对象 |
| Date | 日期对象 |
| RegExp | 对象正则表达式对象–定义文本匹配与筛选规则 |
| String | 字符串对象–定义字符串属性和方法 |

---

## Date对象的创建

**获取当前日期及时间**

```js
const 变量名 = new Date()
```

**设置指定时间**

```js
var 变量名 = new  Date(年，月，日);
var 变量名 = new  Date(年，月，日，时，分，秒，毫秒);
```

## Date对象中的常用方法

1. to方法组:(转换)

- `toString()`把日期转换成字符串
- `toLocaleString()`把日期转换成本地时间(年月日时分秒)
- `toLocaleDateString()`把日期转换成本地时间(年月日)
- `toLocaleTimeString()`把日期转换成本地时间(时分秒)

2. get方法组:(获取)

- `getDate()`获取一个月的某一天日期(1-31)
- `getDay()`获取一周中的某一天(0-6)—(星期天是0)
- `getMonth()`获取月份(0-11)
- `getFullYear()`获取四位数字的年份
- `getHours()`获取小时数(0-23)
- `getMinutes()`获取分钟数(0-59)
- `getSeconds()`获取秒数(0-59)

3. set方法组:(`设置`)

- `setDate()`设置一个月的某一天日期(1-31)
- `setMonth()`设置月份(0-11)
- `setFullYear()`设置四位数字的年份
- `setHours()`设置小时数(0-23)
- `setDay`(这个真`没有!!!!`,`星期是通过设定日期自动计算的`)
- `setFullYear(year，month，day)`

> `year`:`必需`表示年份的四位整数。
>
> `month`:`可选`,介于 `0 ~ 11` 之间。如果不填，取系统当月-1为去年的最后一个月,12为明年的第一个月,13为明年的第二个月。
>
> `day`:`可选`，表示月中某一天的数值。如果不填，取系统当日本地时间表示。介于 1 ~ 31 之间,0 为上个月最后一天,-1 为上个月最后一天之前的天数,如果当月有31天: 32 为下个月的第一天,如果当月有30天: 32 为下一个月的第二天。

- `setHours`(`hour`,`min`,`sec`,`millisec`): 可以有4个参数: `hour`:小时, `min`:分钟, `sec`:秒, `millisec`:毫秒

## 字符串的常用方法

1. `length`: 获取字符串的长度

```js
const str = '中华人民共和国'
alert(str.length)	// 7
```

2. `slice(start[,end])`截取字符串，`start`–开始索引 `end`–结束索引
**返回:包含开始位置，不包含结束位置(含头不含尾)**

```js
const str = '中华人民共和国'
const str1 = str.slice(2, 4)// 人民
```

3. `substring(start [,end])`截取字符串，`start`:开始的索引位置,`end`: 结束的索引位置(不写到末尾)
**返回:包含开始位置，不包含结束位置(含头不含尾)**

```js
const str = '中华人民共和国'
const str1 = str.substr(2, 4)	// 人民
```

4. `substr(start[,length])`，`start`:开始的索引位置,取`length`个字符(不写到末尾)

```js
const str = '中华人民共和国'
const str1 = str.substr(2, 5)	// 人民共和国
```

5. `split()`，按条件分割字符串，返回一个字符串数组

```js
const str = '中华人民共和国'
const arr = str.split('') // ["中", "华", "人", "民", "共", "和","国"]
const str1 = '杏|石|口|路|81|号'
const arr1 = str1.split('|') // ["杏", "石", "口", "路", "81", "号"]
```

6. `indexOf()`:在父串中首次出现的位置索引，从0开始！没有就返回-1

7. `lastIndexOf()`:倒序查找

8. `charAt(index)`:获取指定索引的字符

9. `toLowerCase()`:转小写

10. `toUpperCase()`:转大写

## 数组

Array (数组)对象用于在单个的变量中存储多个值。数组可存放任意数据类型，并通过索引来访问每个元素。

### 数组的声明

1. 先声明再赋值:

- 声明方式1:var arr = new Array(); // 可根据需要在( )中指定长度
- 声明方式2:var arr = [];

赋值:数组名[索引] = 值; // arr[0] = 10;

2. 直接声明并赋值

```js
var arr = new Array("值1",,,,,,"值N");
```

### 数组的长度:

```js
数组名.length
```

### 数组的遍历方式

1. 循环遍历

```js
for (let i = 0; i < arr.length; i++) {
  document.write(arr[i])
}
```

2. 直接输出数组名

```js
document.write(arr)
```

### 数组的常用方法:

1. `join()`: 用指定的元素对数组进行分割。

```js
var arr = [10,20,30];
document.write(arr.join(“*”));  // 10*20*30
```

2. `indexOf`:搜索一个指定的元素的位置，如未找到返回 -1；

```js
const arr = [10, 20, '30', 'abc']
console.log(arr.indexOf(10)) // 元素10的索引为0
console.log(arr.indexOf(30)) // 元素30未找到，返回-1
// 注意:数字30和字符串"30"是不同元素
```

3. `concat()`:把当前的数组 和 另一个数组连接起来，并返回一个新的 数组；

```js
const arr1 = ['a', 'b', 'c']
const arr2 = [1, 2, 3]
const newArr = arr1.concat(arr2, '再次添加')
console.log(newArr) // ["a","b","c",1,2,3,"再次添加"];
console.log(arr1) // ["a","b","c"]
```

4. `push()`:向数组的末尾添加若干元素

```js
pop(): 把数组的最后一个元素删除掉
var arr = [1,2];
arr.push("a","b");
console.log(arr);//[1,2,"a","b"]

arr.pop(); //返回“b”;
console.log(arr); //[1,2,"a"]

arr.pop();
arr.pop();
arr.pop();  //连续3次pop，空数组继续pop不会报错
console.log(arr); //打印[]
```

5. `unshift()`: 向数组前面添加若干元素

6. `shift()`: 则把数组的第一个元素删除掉

```js
const arr = [1, 2]
arr.unshift('a', 'b') // 返回新长度 4
console.log(arr)// 打印["a","b",1,2]

arr.shift()// 返回"a"
console.log(arr) // 打印["b",1,2]

arr.shift(); arr.shift(); arr.shift() // 连续3次
console.log(arr) // 打印[]

arr.shift() // 空数组继续删除不报错，返回undefined
console.log(arr) // 打印[]
```

7. `slice()`: 截取数组的部分元素，然后返回一个新的数组

```js
var arr = ["a","b","c","d","e","f","g"];
console.log(arr.slice(0,3)); //从索引0开始，到索引3结束，但不包括3:["a","b","c"]
console.log(arr.slice(3));  //从索引3开始到结束:"d","e","f","g"
如果不给slice()传递任何参数，他就会从头到尾截取所有元素。利用这一点，可以很容易的复制一份新的数组
var arr = [1,2,3];
var aCopy = arr.slice();
console.log(aCopy); //[1,2,3]
```

8. `sort()`: 可以对当前数组排序

```js
const arr = ['b', 'c', 'a']
arr.sort()
console.log(arr)// ["a","b","c"]
```

9. `reverse()`: 把整个数组的元素给掉个个，也就是反转

```js
const arr = ['one', 'two', 'three']
arr.reverse()
console.log(arr) // ["three","two","one"]
```

10. `join()`: 把数组的每个元素用指定的字符串连接起来，然后新的字符串

```js
const arr = ['a', 'b', 'c', 1, 2, 3]
arr.join('-') // "a-b-c-1-2-3"
```

11. `splice()`: 是修改数组的“万能方法”，他可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素;

```js
// splice(索引值，删除数量，"值1"，"值2");
const arr = ['苹果', '橘子', '香蕉', '芋头', '桂圆', '山楂']

// 从索引2开始删除3个元素，然后再添加两个元素
arr.splice(2, 3, '白梨', '西瓜')
console.log(arr) // "苹果","橘子","白梨","西瓜","山楂"

// 只删除，不添加
arr.splice(2, 2) // "白梨","西瓜"
console.log(arr) // "苹果","橘子","山楂"

// 只添加，不删除
arr.splice(2, 0, '白梨', '西瓜')
console.log(arr)// "苹果","橘子","白梨","西瓜","山楂"
```

## Math的常用方法

| 方法 | 说明 |
| --- | --- |
| abs() | 绝对值 （去除正负） |
| random() | 随机数，0-1之间的随机数，1不会出现 |
| round() | 四舍五入 |
| floor(x) | 下舍入(向下取整)–地板 |
| ceil(x) | 上舍入(向上取整)–天花板 |
| max(x,y) | x 和 y 中的最大值 |
| min(x,y) | x 和 y 中的最小值 |
| cos(x) | 的余弦 |
| sin(x) | x的正弦 |
| sqrt(x) | 返回x的平方根 |
| pow(3,4) | 返回3的4次方 |

**Math函数的属性：`PI` 圆周率。使用方法：`Math.PI`**

## 全局对象中的常用方法（强制转换）

1. `isNaN()`:判断是否是数字，不是数字返回true，是数字返回false;(`isNaN:is not a number`)
2. `eval()`把字符串里面的数字进行计算
3. `parseFloat()`把字符串转换为小数
4. `parseInt()`把字符串转换为整数

## 函数的定义、调用

1. 函数的概念

> 函数是ECMAScript的核心，包含一些代码，只有被调用以后才会执行。函数是对象数据类型的一种。

2. 定义函数的语法：

```js
function 函数名(参数){
  函数体(也称为：方法体);
}
```

3. 函数的调用

> 函数名(参数值);

## 正则表达式

1. 正则表达式的概念

> `RegExp`（正则表达式）是一个对象，就是用一个“字符串”来描述一个特征，然后去校验另一个“字符串”是否符合该特征。主要实现对`字符串的匹配`、`分割`、`查找`、`替换`、`校验`等操作。

2. 元字符

**正则模式当中的元字符，通常都具有特殊的含义**

| 元字符 | 说明 |
| --- | --- |
| a-z | 英文小写字母 |
| A-Z | 英文大写字母 |
| 0-9 | 数字 |
| \r \n \t | 非打印字符 |
| \d | 数字，相当于0-9 |
| \D | \d 取反 |
| \w | 字母 数字 下划线 |
| \W | \w 取反 |
| \s | 空白字符 |
| \S | 非空白字符 |
| \[ \] | 任意匹配\[ \]中单个字符 |
| . | 匹配任意字符（换行符除外） |
| \{n} | 匹配n次 |
| \{n,} | 匹配至少n次 |
| \{n,m} | 至少n次，最多m次 |
| \* | 匹配0个或多个，相当于\{0,} |
| + | 匹配1个或多个，相当于\{1,} |
| ? | 匹配0个或1个，相当于\{0,1} |
| ^ | 1、匹配正则开头 2、放在\[^\]，内容取反 |
| $ | 匹配正则结尾 |
| | | 匹配 | 两侧任选其一 |
| ( ) | 1\. 分组 2.子存储 |

\*\*注意：\*\*正则需要转义字符： ( ) { } ? \* + . \[ \] \ / ^ $ |

3. 正则的定义：

  - 方式1：var re = /正则内容/;
  - 方式2：var re = new RegExp(正则内容);

4. test方法：检索字符串中指定的值。返回 true 或 false。

```js
const txt = 'this a cat, that a dog'
const re = /cat/
alert(re.test(txt)) // true
```

---

## BOM概述

- BOM（browser object model）浏览器对象模型

- BOM提供了独立于内容而与浏览器窗口进行交互的对象、载入页面的相关信息，其核心对象是 window 对象。

- BOM 没有相关标准，每个浏览器都定义了自己的属性，并且，都有其自己对 BOM 的实现方式。

- W3C 虽然没有为 BOM 统一制定标准,但是其中的窗口对象、导航对象等,因功能趋同,实际上已经成为默认的标准。

## BOM对象

### window对象

window 对象（宿主对象）表示一个浏览器窗口（或一个框架），所有浏览器的属性和方法，都被定义在 window 这个对象之上。

js 通过 window 对象，就可以对浏览器进行操作（读取/修改浏览器属性、操作标签元素、响应用户事件等）。

window 对象是全局对象，并且是唯一的，因此在使用中可以省略不写，例如：可以只写 document，而不必写 window.document。同样，可以把 window 对象的方法当作函数来使用，如只写 alert()，而不必写 window.alert()。

**window方法**

| window的方法 | **说明** |
| --- | --- |
| alert() | 提示框 |
| confirm() | 带有确认 取消 按钮的提示框(返回true或false) |
| prompt() | 带有可输入内容的文本域 的提示框 |
| setInterval() | 间隔定时器，可按照指定的周期（以毫秒计）来调用函数或计算表达式 |
| clearInterval() | 清除间隔定时器 |
| setTimeout() | 超时定时器，在指定的毫秒数后调用函数 |
| clearTimeout() | 清除超时定时器 |
| open() | 打开一个新的浏览器窗口 |
| close() | 关闭窗口 |

## history 历史记录

### history的属性

length: 返回浏览器历史列表中URL的数量

### histroy的方法

1. window.history.go() 刷新

2. window.history.go(1) 前进（跳转）

3. window.history.go(-1) 后退（跳转）

4. window.history.forward() 前进

5. window.history.back() 后退

## location 定位

1. location的属性

- protocol: 当前的URL协议

- hostname: 当前URL的主机名

- port: 当前URL的端口号

- host: 当前的URL主机名和端口号

- pathname: 当前的URL的路径

- hash: 以#开始的URL的锚（想要达到页面中的固定位置时使用）

- search: 以？开始的URL拼接部分

- href: 当前URL的完整路径

2. location的方法

- assign() 加载新的文档（原始页面可以返回，仍然存在）

- reload() 页面重载

- replace() 用新文档替换当前文档（原始页面不可以返回，不存在）

## navigator 导航

1. window.navigator.userAgent 浏览器类型、版本、操作系统类型、浏览器引擎类型等信息

2. navigator.appName

3. navigator.appVersion

4. navigator.cookieEnabled

5. navigator.platform

---

## DOM介绍

DOM（document object model ）文档对象模型，定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。它是一个能让程序和脚本动态访问和更新内容，结构和样式的语言平台。

## DOM中的常用属性

1. title: 设置或返回当前页面的标题。

2. body: 提供对body元素的直接访问。

3. cookie: 设置或返回与当前文档有关的的所有cookie。

4. domain:返回当前文档的域名。

5. referrer: 返回载入当前文档的URL。

6. URL: 返回当前文档的URL。

## DOM中的常用方法

1. scrollLeft: 页面在水平方向上的滚动距离

2. scrollTop: 页面在垂直方向上的滚动距离

3. clientWidth: 页面可见区域的宽度

4. clientHeight: 页面可见区域的高度

## DOM中的innerText、innerHTML、style属性

- innerText: 获取或设置指定的页面元素内容

- innerHTML: 获取或设置指定的页面元素内容（含有html标签）

- style: 获取或设置样式

## DOM中表单对象的常用方法

- reset(): 重置

- submit(): 提交表单

## DOM中表单对象的常用属性

- action: 设置或返回表单的action属性(即：提交的路径)

- enctype: 设置或返回表单数据在发送到服务器之前的编码方式

- id: 设置或返回表单id

- length: 返回表单中的元素个数

- method: 设置或返回将数据发送到服务器的http方法

- name: 设置或返回表单name名称

- target: 设置或返回表单提交结果的frame或window名

- elements: 即一个数组，包含所有的表单元素

---

## 基本类型和引用类型的值

1. ECMAScript 的数据类型包括两种：基本数据类型和引用数据类型。

2. 基本数据类型指的是简单的数据段，常见的基本数据类型有： number, string, boolean, null, undefined。

3. 引用数据类型指的是由多个值构成的对象，常见的引用数据类型（即：对象类型 Object type）有： Object, Array, Function, Date等。

4. 当我们对变量赋值时，解析器首先要确认的就是这个值是基本类型值，还是引用类型值。

5. 两种数据类型的区别点如下：
  - 声明变量时不同的内存分配。基本类型的值保存在栈内存中，引用类型的值同时保存在栈内存和堆内存中。
  - 不同的内存分配机制也带来了不同的访问机制。
  - 赋值变量时的不同。不能给基本类型的值添加属性。
  - 参数传递的不同（把实参赋值给形参的过程）。

6. 值的比较：
  - 基本类型的比较是值的比较；
  - 引用类型的比较是引用的比较；

## 执行环境及作用域

1. 执行环境介绍

执行环境是 JavaScript 中最重要的一个概念。执行函数定义了变量或函数有权访问的其他数据，决定了他们各自的行为。
每个执行环境都有一个与之关联的变量对象(variable object)和一个作用域链(scope chain)，环境中定义的所有变量和函数都保存在其变量对象中。执行环境分为两种，即：全局执行环境和函数执行环境。

2. 全局执行环境

全局执行环境是最外围的一个执行环境，其变量对象就是全局活动对象(window activation object)，全局执行环境直到应用程序退出（例如：关闭网页或浏览器）时才会被销毁。

3. 函数执行环境

每个函数都有自己的执行环境。当执行流进入一个函数时，函数环境就会被推入一个环境栈中。当函数执行完之后，栈将该执行环境弹出，把控制权返回给之前的执行环境。函数执行环境的变量对象是该函数的活动对象(activation object)。

4. 作用域链

对于每一个执行环境，都会创建一个与之关联的作用域链。每个执行环境的作用域链的前端，始终都是该执行环境的变量对象，对于全局执行环境就相当于 window 对象，对于函数执行环境就相当于该函数的活动对象；对于全局执行环境，已经是根部，没有后续；对于函数执行环境，其作用域链的后续就是该函数对象的 scope 属性里的作用域链。

## 垃圾收集

JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。

1. 标记清除：

JavaScript中最常用的垃圾收集方式是标记清除。

垃圾收集器会在运行的时候给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。

在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收它们所占用的空间。

2. 引用计数：

引用计数是不太常见的垃圾收集策略。

引用计数的含义是跟踪记录每个值被引用的次数。

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，如果该值同时赋给另一个变量，则该值引用次数加1。相反，如果包含对这个值引用的变量又取了另一个值，则该值引用次数减1。

当这个值引用次数变成0时就说明没有办法再访问该值了，可将其占用的内存空间回收。

当垃圾收集器下次运行时，就会释放那些引用次数为0的值所占用的内存。

**另外，垃圾收集处理方式除了以上两种策略，还可以进行`垃圾周期处理`和`解除引用`。**

垃圾周期处理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性地执行这一操作。

解除引用：对于全局变量，当不再使用时，使用null赋值是一个良好的习惯。

---

JavaScript是基于对象编程的，面向对象是一种编程思想。

## 类和对象

1. 类：我们善于将事物进行分类，类是一个抽象的概念。

2. 对象：具体的事物。如猫是一类，楼下的大黄就是对象。

3. 类是对象的抽象，对象是类的具体事例。

4. 类不占用内存，对象占用内存空间。

## Object类型

- Object对象，是所有JavaScript对象的超类（基类）。

- Object.prototype（Object的原型）定义了JS对象的基本方法和属性。

### 声明对象(Object变量定义)

- 字面量声明 var obj = {};

- new运算符 var obj = new Object();

### 对象类型的判断

```js
console.log(typeof obj)
```

### 添加对象属性的方法

1. 语法 ：[obj.id](http://obj.id/) = “abc”;

2. \[ \]方括号语法： obj\[“id”\]= “abc”;

### 删除对象属性的方法

- delete [obj.id](http://obj.id/);

- delete obj\[“id”\];

### 遍历对象

- for in 循环

```js
const obj = {
  name: 'zhangsan',
  age: 20,
}
for (const key in obj) {
  console.log(key, obj[key])
}
// name zhangsan
// age 20
```

### 检测对象有没有某个属性

```js
if ("name" in obj)         （判断有）
if (obj.name === undefined)（判断没有）
```

## Function类型

Function 类型是 JS 中的引用类型之一，每个函数实际上都是 Function 类型的实例对象，具有自己的属性和方法。正因为函数式对象，所以函数名实际上也是一个指向函数对象的指针。

### 函数的定义方式

1. 使用function关键字定义函数：（函数声明式）

```js
function sum(a, b) {
  return a + b
}
```

2. 通过变量声明（表达式）定义函数：（函数表达式）

```js
const sum = function (a, b) {
  return a + b
}
```

### 函数的调用

1. 通过函数名调用： sum();

2. 事件绑定调用： obj.onclick = sum;

**注意：函数名仅仅保存指向函数对象的指针，隐藏函数名与包含对象指针的其他变量一样。也就是说，一个函数对象可以有多个名字。**

```js
如：function sum(a, b){
return a + b;
}
console.log( sum(5,10) );   // 15

// 变量sum2也指向了同一个函数对象
var sum2 = sum;// sum后面不加括号，不传参数。
console.log( sum2(3,5) );   // 8

sum = null;// sum对象不再保存函数对象的指针了
console.log( sum2(3,5) );   // sum2这个变量仍能继续使用
```

## 函数的重载

所谓重载，就是一组相同的函数名，有不同个数的参数，在使用时调用一个函数名，传入不同参数，根据你的参数个数，来决定使用不同的函数！但是JS中是没有重载的，因为后定义的函数会覆盖前面的同名函数。

在JS中，我们实现重载的常用方式有：

1. 根据传入参数的不同类型进行重载；
2. 利用参数中特殊的参数值进行重载；
3. 根据参数的个数进行重载（最简单的方式：switch case 用法）

## 函数声明式，函数表达式与函数提升

1. JS中的声明函数的方法有两种：函数声明式和函数表达式。

    **两者区别如下：**

    - 函数声明式必须要有函数名，而函数表达式的函数名是可选的。
    - 以函数声明式定义的函数可以在其声明之前被调用，而以函数表达式声明的函数只能在其后被调用。
    - 以函数声明式定义的函数仅仅可以出现在全局中，或者嵌套在其他函数中，不能出现在循环语句，条件语句和try/catch/finally中；而函数表达式可以在任何地方声明。

2. 函数提升

函数提升，即：自动把函数的作用范围提升到全局中。而`只有函数声明式才存在函数提升`。

## 函数内部属性：arguments, this

1. `arguments`：用来存放传输参数的数组，可以被调用多次，每次数组都不一样。
2. `this`：`谁调用函数，谁就是this`。进行方法调用的时候函数前面是有window的，只是通常会省略掉。

## 函数的属性和方法

1. `length`属性：arguments对象的length属性表示实参个数，函数的length属性则表示形参个数。

2. `name`属性：访问到给定函数指定的名字，即：跟在function关键字后的标识符。`匿名函数的name属性为空`。

3. `prototype`属性：是每个函数都有的属性，该属性指向一个对象的引用，这个对象称作`原型对象（prototype object）`。每一个函数都包含不同的原型对象。将函数用做构造函数时，新创建的对象会从原型对象中继承属性。

4. `apply()`方法和`call()`方法：是每个函数都有的方法，等同于函数体内this对象的值。（后面讲解）

## 基本包装类型

为了便于操作基本类型的值，ECMAScript提供了3种特殊的引用类型：`Boolean`, `Number`, `String`。他们与其他引用类型的使用方法相似，同时也具有各自的基本类型的属性。实际上，每当读取一个基本类型的值，后台就会创建一个对应的基本包装类型的对象，从而可以调用对应的方法。

1. `Boolean`类型：没有特定的属性和方法。

2. `Number`类型：有静态属性，可以直接调用里面的属性和方法，`无需new出来`。

3. `String`类型：包含String对象属性，字符串方法，字符串操作方法，字符串位置方法等。

## JS内置对象介绍

1. String对象：字符串对象

2. Array对象：数组对象

3. Date对象：日期时间对象

4. Boolean对象：布尔对象

5. Number对象：数值对象

6. Math对象：数学对象

7. RegExp对象：正则对象

---

## 匿名函数

### 工厂模式

假如我们把猫看成是一类，都有名字和颜色的属性，那么，每一只猫就是这个类的实例，我们可以使用字面量方式定义对象：

```js
const cat1 = {
  name: '大黄',
  color: '黄色',
  say() {
    alert('miao')
  }
}

const cat2 = {
  name: '小黑',
  color: '黑色',
  say() {
    alert('miao')
  }
}
```

- 这样创建对象，一是创建对象比较麻烦，二是实例与原型（猫类）之间，没有任何联系。

- 为了简化代码书写，我们可以写一个函数批量创建对象，也就是使用`“工厂模式”`：

**（工厂模式中的函数，首字母大写）：**

```js
function Cat(n, c) {
  return {
    name: n,
    color: c,
    say() {
      alert('miao')
    },
  }
}
```

**生成实例对象，就等于是在调用函数**

```js
const cat1 = Cat('大黄', '黄色')
const cat2 = Cat('小黑', '黑色')
```

> 这样代码虽然简单了，但是实例之间还是没有什么联系。

### 构造函数

- 为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。

- 所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。

- 构造函数首字母大写，没有return语句，没有显式地创建对象。

- 构造函数中的this，指向的是实例化的对象

**例如：**

```js
function Cat(n, c) {
  this.name = n
  this.color = c
}
```

- 生成实例对象

```js
const cat1 = new Cat('大黄', '黄色')
const cat2 = new Cat('小黑', '黑色')
```

- 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。

```js
alert(cat1.constructor == Cat) // true
alert(cat2.constructor == Cat) // true
```

- Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
- instanceof不认为基本类型值的变量是对象。

```js
const txt = 'adsdf'
alert(txt instanceof String)// false

const age = 123123
alert(age instanceof Number)// false

const re = /\d/
alert(re instanceof RegExp)// true

const arr = []
alert(Array.isArray(arr))// true
```

### 原型模式和原型链

- 每类对象的实例对象，都有可能会有一些相同的属性，或者相同的功能，如果都写在构造函数上，会造成重复的内容，占用更多的内存。

- 为了解决这种代码的重复，我们可以使用原型模式。

- 构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。

- 我们可以把那些不变的属性和方法，直接定义在prototype对象上。让实例对象共享其属性和方法。

```js
Cat.protoType.say = function () {
  alert('miao')
}
cat1.say()// miao
cat2.say()// miao
```

- 所有的函数都是 Function 的实例。在构造函数上都有一个原型属性—prototype，prototype也是一个对象；这个对象上有一个 constructor 属性，该属性指向的就是构造函数。

- 而实例对象上有一个_proto_属性，该属性也指向原型对象，该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。

### 组合使用构造函数模式和原型模式

- 构造函数与原型模式组合的模式是目前使用最广泛、认同度最高的一种创建定义类型的方法。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。

- 每个实例都会有自己的一份实例属性的副本，同时共享着对方法的引用，最大限度节省内存。同时，这种组合模式还支持向构造函数传递参数，集合了两种模式的优点。

### 动态原型模式

动态原型模式就是把所有信息都封装在构造函数中，通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

### 寄生构造函数模式

寄生构造函数模式的基本思想，是创建一个用于封装创建对象的函数。主要用于创建一个自定义类型的函数。

### 稳妥构造函数模式

- 稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。适合在一些安全的环境中（禁用this和new的环境），或者防止数据被其他应用程序调用时使用。
- 稳妥构造函数遵循与寄生构造函数类似的模式，只是有两点不同：新创建对象的实例方法不引用this；不使用new调用构造函数。

### 原型链

原型链可以简单理解为原型组成的链，对象的_proto_就是其原型，而原型也是一个对象，也有_proto_属性。原型的_proto_又是原型的原型，这样可以一直向上找，直到找到Object的原型，就是这条原型链的顶端。

### 借用构造函数，也称伪造对象或经典继承

借用构造函数实现继承的基本思想是：在子类的构造函数中调用超类的构造函数。该函数可以通过apply()方法和call()方法在新创建的对象中执行构造函数。

优点：相对于原型链而言，借用构造函数可以在子类构造函数中向超类构造函数传递数据。

缺点：构造函数的方法都在构造函数中定义，因此无法实现函数复用。另外，子类无法看见在超类中定义的方法，导致所有类型只能使用构造函数模式。

### 组合继承

组合继承，又称为伪经典继承。指：将原型链和借用构造函数的技术组合在一起，从而发挥两者长处的一种继承模式。

其思想是：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样，我们就可以实现通过在原型上定义方法进而实现函数复用，又能保证每个实例都有自己的属性，解决原型链中存在的引用类型属性共享问题。

### 原型式继承

原型式继承，即：一个构造方法，通过原型链的方式继承另一个构造函数。

### 寄生式继承

寄生式继承，即：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回该对象。

### 寄生组合式继承

寄生组合式继承是JS最常用的继承模式，其最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类原型时，另一次是在子类构造函数内部。

## 函数操作

### 函数表达式

使用函数表达式创建的函数，必须先赋值再调用。（即：只有函数声明式才有函数提升，函数表达式没有函数提升。）

```js
fn2() // 不能在函数之前调用。
var fn2 = function () {
  console.log('2.演示函数表达式')
}
fn2() // 只能在函数之前调用。
```

**虽然函数表达式没有函数提升，但是它也有自己的一些优点。**

## 递归函数

递归函数，就是在函数体内调用本函数。最简单的例子就是计算阶乘： 1_2_3…。

递归的缺点：如果递归函数的终止条件不明确甚至缺失，会导致该函数长时间运行，使用户界面处于假死状态。另外，当递归使用太多甚至超过最大调用栈内存容量时，浏览器会报错。

### 闭包

闭包，是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数。

JS中，一般为了给某个函数声明一些只有该函数才能使用的局部变量时就会使用闭包，这样可以减少全局作用域中的变量，净化全局作用域。但是闭包会占用更多的内存。

## 模仿块级作用域

**JS中没有块级作用域，我们可以进行模仿块级作用域。**

使用方式：简单来讲，就是定义并立即调用一个匿名函数。具体步骤，就是将匿名函数声明（函数表达式）在一对圆括号中，而紧随其后的一对圆括号会立即调用该函数。

### 私有变量

严格来讲，JS中没有私有成员的概念，所有对象属性都是公开的。但是，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数外部访问。私有变量包括函数参数，局部变量以及在函数内部定义的其他函数。闭包函数可以持有这些私有变量，并在外部访问。

---

## AJAX介绍和创建XHR对象

AJAX:异步 JavaScript 和 XML。简短地说，在不重载整个网页的情况下，AJAX通过后台加载数据，并在网页上进行显示。

**AJAX包括以下几个步骤：**

创建AJAX对象；发出HTTP请求；接收服务器传回的数据；更新页面数据；

**Ajax的工作原理如图所示：**

![Ajax的工作原理](/image/e35455a5eb0da1e4128ebe207590041d.webp)

**总结：**

- AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后再进行处理。
- AJAX技术的核心就是XMLHttpRequest对象（简称：XHR），这是微软首次引入的一个特性，其他浏览器厂商后来都提供了相同的实现。
- IE5中的XHR对象是通过ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象。
- 创建一个XHR对象，也叫做实例化一个XHR对象，因为XMLHttpRequest()是一个构造函数。

## XHR的用法介绍

1. `open()`方法：设置: HTTP方法和要获取资源的URL;

2. `send()`方法：发送请求；

3. `onload`属性：设置: 成功获取数据后将要运行的函数；

4. `onerror`属性：设置: 出现错误后将要运行的函数；

5. `responseText`属性：设置: 存储异步请求响应的文本;

## HTTP头部信息

请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。XHR对象也提供了操作这两种头部信息（请求头和响应头）的方法。

1. `Accep`t：告诉WEB服务器自己接受什么介质类型，_/_ 表示任何类型，type/\* 表示该类型下的所有子类型，type/sub-type。
2. `Accept-Charset`：浏览器告诉服务器自己能接收的字符集。
3. `Accept-Encoding`：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。
4. `Accept-Language`：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。
5. `Cache-Control`：指定请求和响应遵循的缓存机制。
6. `Connection`：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1，它就表示持久连接。
7. `Cookie`：当前域名下的Cookie。
8. `Referer`： 浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL。
9. `User-Agent`：浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0

## GET与POST请求

- 由于GET方式在发送数据时是将参数拼接在URL上，传输数据会受到URL长度的限制，不同浏览器的长度限制不一样，所以GET方式会受到参数大小的限制，但是POST方式没有参数大小的限制。

- 因为GET方式会将请求参数显示在地址栏上，而POST方式不会，所以POST方式相对来讲更安全。

- GET方式有缓存，而POST方式没有缓存。

## JavaScript中的跨域请求

受JS同源策略的影响，当在某一域名下请求其他域名，或在同一域名下请求不同端口的URL时，就会变成不被允许的跨域请求。127.0.0.1:8020

## 了解XDomainRequest对象

`XDomainRequest`表示JavaScript和Ajax的跨域请求，在IE8+可以使用。

`XDomainRequest`包含以下几个部分：

1. 事件
  - `onload`事件：请求成功并返回对象时，被触发。
  - `onerror`事件：当跨域请求发生错误时，被触发。
  - `onprogress`事件：浏览器开始从服务器端接收数据时，被触发。
  - `ontimeout`事件：出现超时情况，被触发。

2. 方法
  - `abort`方法：终止等待send
  - `open(XDomainRequest)`方法：建立与服务器的链接
  - `send(XDomainRequest)`方法：传输一个字符串数据给服务器处理

3. 属性
  - `constructor`属性：返回一个对象的构造函数的引用
  - `contentType`属性：返回html请求或返回头部的content-type属性
  - `responseText`属性：以字符串形式返回请求的body内容
  - `timeout`属性：超时后返回的值。

## JSON数据

`JSON(JavaScript Object Notation`, JS 对象简谱) 是一种轻量级的数据交换格式。

它基于 `ECMAScript` (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。

简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。

**Json的语法可以表示成三种类型的值：**

1. 简单值：可以在Json中表示字符串、数值、布尔值和null，但是`不支持undefined`;

2. 对象：作为一种复杂数据结构，表示一种无序的键值对，每个键值对中的值既可以是简单值，也可以是复杂数据类型的值。

3. 数组：作为一种复杂数据结构，表示一种有序值的列表，可以通过数组索引访问其中的值。数组中的元素可以是任何类型：简单值、对象、数组均可。

**如：**

```js
const obj = { a: 'Hello', b: 'World' }
// 这是一个对象，注意键名也是可以使用引号包裹的
const json = '{"a": "Hello", "b": "World"}'
// 这是一个 JSON 字符串，本质是一个字符串
```

## 在Ajax中使用JSON数据

1. `JSON.parse()`：把Json格式的字符串转换为Json对象。

2. `JSON.stringify()`:把Json对象转换为Json格式的字符串。

---

## sessionStorage、localStorage和cookie

相同点：都是保存在浏览器端、且同源的。

区别：

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。

2. 存储大小限制也不同，cookie数据不能超过4K（小于4096），同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭。

4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

5. web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。

6. web Storage的api接口使用更方便。

7. `sessionStorage`用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此`sessionStorage`不是一种持久化的本地存储，仅仅是会话级别的存储。而`localStorage`用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

## Cookie

什么是Cookie：cookie是存储于用户计算机中的变量。每当该计算机通过浏览器请求某个页面时，就会发送这个cookie。我们可以使用JavaScript来创建和获取cookie的值。

cookie的存储形式：键值对，如：name=张三

使用JS创建Cookie的格式：`document.cookie = “name=张三”;`还可以为cookie添加一个过期时间（UTC或GMT,默认情况下，cookie在浏览器关闭时删除）。如：

```js
document.cookie = “name=张三;
expires=Thu, 18 Dec 2019 12:00:00 GMT”;
```

使用JS读取Cookie的格式： `var X = document.cookie;`

修改Cookie：JS中修改cookie类似于创建cookie，旧的cookie会被覆盖掉。

删除Cookie：只需设置expires参数为以前的时间即可。如：

```js
document.cookie = “name=张三;
expires=Thu, 18 Dec 2019 12:00:00 GMT”;
```

Cookie的缺点：Cookie可能被用户禁用。同一个页面被不同浏览器访问时，浏览器之间保存的Cookie不能相互访问。每个Cookie都保存在客户端硬盘文件上，可能会被删除。Cookie安全性不高，所有Cookie都是以纯文本形式记录于文件中。

## Web存储机制

- HTML5提供了一种新的对象`Storage`，类似于`String`、`Number`、`Object`。通过Storage对象提供的方法和属性来对数据进行增删改查。

- html5中的`Web Storage`包括了两种存储方式：`localStorage`和`sessionStorage`。两者都是用来存储客户端临时信息的对象。

- `sessionStorage`用于本地存储一个会话（`session`）中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据也随之销毁。因此`sessionStorage`不是一种持久化的本地存储，仅是会话级别的存储。只允许同一窗口访问。而`localStorage`用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改`localStorage`数据。并且他们储存的对象类型均为字符串类型；我们将数据以键值对的形式保存到`Storage`对象里，通过`Storage`对象提供的方法进行数据操作。

```js
// 1. 增：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。
Storage.setItem()

// 2. 删
// 清空存储中的所有键名
Storage.clear()
// 接受一个键名作为参数，并把该键名从存储中删除。
Storage.removeItem()

// 3. 改：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。
Storage.setItem()

// 4. 查
// 接受一个键名作为参数，返回键名对应的值
Storage.getItem()
// 接受一个数值 n 作为参数，并返回存储中索引为n 的键名
Storage.key()
// 返回存储的数据量
Storage.length
```

## sessionStorage对象

sessionStorage对象存储某个特定会话的数据，该数据只保持到浏览器关闭（类似于cookie）。

存储在sessionStorage对象中的数据可以跨越页面刷新而存在。部分浏览器也支持在浏览器崩溃的情况下重启仍然可用（如：Firefox和WebKit等，但是IE不支持）。

sessionStorage对象其实是Storage对象的一个实例，具体方法如下：

1. sessionStorage.length:获取存储在Storage对象中的数据的数量，是一个只读属性。
2. sessionStorage.key():接受一个数值 n 作为参数，并返回存储中索引为n 的键名。
3. sessionStorage.getItem():接受一个键名作为参数，返回键名对应的值。
4. sessionStorage.setItem()：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。
5. sessionStorage.clear()：清空存储中的所有键名。
6. sessionStorage.removeItem()：接受一个键名作为参数，并把该键名从存储中删除。

## globalStorage

globalStorage在浏览器关闭以后，使用globalStorage存储的信息仍能够保留下来，localStorage一样，域中任何一个页面存储的信息都能被所有的页面共享。

```js
// 在developer.mozilla.org下面所有的子域都可以通过这个命名空间存储对象来进行读和写
globalStorage['developer.mozilla.org']

// 在mozilla.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写
globalStorage['mozilla.org']

// 在.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写
globalStorage.org

// 在任何域名下的任何网页都可以通过这个命名空间存储对象来进行读和写
globalStorage['']

// 注意：globalStorage对象已经被localStorage对象取代。
```

## localStorage对象

localStorage的优势：

1. localStorage拓展了cookie的4k限制。
2. localStorage可用将第一次请求的数据直接存储到本地，相当于5M大小的针对于前端页面的数据库，相比于cookie可用节约带宽，但是只有在高版本浏览器中才支持。

localStorage的局限：

1. 只有在IE8以上浏览器才支持localStorage的存储功能。
2. 目前所有浏览器都会把localStorage的值类型限定为string，这需要我们转换为JSON对象类型。
3. localStorage在浏览器的隐私模式下不可读取。
4. 由于localStorage在本质上是对字符串的读取，所以如果存储的内容较多，会消耗掉内存空间，导致页面卡顿，加载速度减慢。
5. localStorage不能被爬虫抓取到。

localStorage对象的具体方法与sessionStorage的方法一致。

......
